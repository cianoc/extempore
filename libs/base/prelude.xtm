;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; standard prelude for xtlang
;;

;; prelude loads algebraic data types
(sys:load "libs/base/adt.xtm")

(bind-alias Bool i1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; currying

(bind-func curry:[[!r,!a]*,[!r,!a]*]*
  (lambda (f) f))

(bind-func curry:[[[!r,!b]*,!a]*,[!r,!a,!b]*]*
  (lambda (f) (lambda (a) (lambda (b) (f a b)))))

(bind-func curry:[[[[!r,!c]*,!b]*,!a]*,[!r,!a,!b,!c]*]*
  (lambda (f) (lambda (a) (lambda (b) (lambda (c) (f a b c))))))

(bind-func curry:[[[[[!r,!d]*,!c]*,!b]*,!a]*,[!r,!a,!b,!c,!d]*]*
  (lambda (f) (lambda (a) (lambda (b) (lambda (c) (lambda (d) (f a b c d)))))))

(bind-func curry:[[[[[[!r,!e]*,!d]*,!c]*,!b]*,!a]*,[!r,!a,!b,!c,!d,!e]*]*
  (lambda (f) (lambda (a) (lambda (b) (lambda (c) (lambda (d) (lambda (e) (f a b c d e))))))))

(bind-func flip:[[!r,!b,!a]*,[!r,!a,!b]*]*
  (lambda (fn)
    (lambda (b a) (fn a b))))

(bind-func compose:[[!c,!a]*,[!a,!b]*,[!b,!c]*]*
  (lambda (f g) (lambda (a) (g (f a)))))

(bind-func id:[!a,!a]*
  (lambda (a) a))

(bind-func const:[[!a,!b]*,!a]*
  (lambda (a) (lambda (b) c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Loops etc

;; TODO Optimization. Only use 'begin' if we're not inside one of the following case cond do
;; lambda let if. Probably should be a generalized function as this seems
;; useful.
(bind-macro
  "
Always run the expression at least once before testing the predicate.
@param - The expression inside the until loop
@param - the predicate

@example (until (= x 4)(println \"hello\"))
"
  (until pred exp)
  `(begin (,exp (while ,pred ,exp))))

;; (macro-expand '(xtmacro_until (= x 4) (println "hello")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; maybe 
;;

(bind-data Option{!a}
           (Some !a)
           (None))

(bind-func toString:[String*,Option{!a}*]*
  (lambda (F)
    (Some$ F (x)
              (toString x)
              '_')))

(bind-func print:[void,Option*]*
  (lambda (F)
    (printout (toString F))))

;; also known as map, lift
(bind-func fmap:[Option{!b}*,[!b,!a]*,Option{!a}*]*
  (lambda (f F)
    (Some$ F (x) (Some (f x)) (None))))

(bind-func join:[Option{!a}*,Option{Option{!a}*}*]*
  (lambda (M)
    (Some$ M (x) x (None))))

;; it's more convenient to have the function in last arg position
(bind-func flatmap:[Option{!b}*,Option{!a}*,[Option{!b}*,!a]*]*
  (lambda (M f)
    ;; (join (fmap f M)))) ;; alternate using join & fmap
    (Some$ M (x) (f x) (None))))    

;; also known as return or pure
(bind-func unit:[Option{!a}*,!a]*
  (lambda (x)
    (Some x)))

;; also known as >>=
(bind-func bind:[Option{!b}*,Option{!a}*,[Option{!b}*,!a]*]*
  (lambda (mx f)
    (Some$ mx (x)
           (Some (f x))
           (None))))

;; also known as Kleisli arrow >=>
(bind-func mcompose:[Option{!c}*,!a]*,[Option{!b}*,!a]*,[Option{!c}*,!b]*
  (lambda (f g)
    (lambda (x)
      (bind (f x) g))))

;; also known as <*> or ap
(bind-func apply:[Option{!b}*,Option{[!b,!a]*}*,Option{!a}*]*
  (lambda (F1 F2)
    (Some$ F1 (f)
              (Some$ F2 (x)
                        (Some (f x))
                        (None))
              (None))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Array List
;; Also known as Vector, Dynamic Array, etc

;; pointer to the base of the array, the length, the allocated size
;; ArrayLists are allocated space on the heap.
;; but their life cycle is aligned with the zone they are attached to.
(bind-type ArrayL{!a} <!a,i64,i64,mzone*> (#f)
  "
Also known as Vector, Dynamic Array, etc.
This is an array that grows (and shrinks) as necessary.

An ArrayList allocated on a zone will be freed when the current zone is destroyed. An ArrayList allocated on the heap will have to be manually freed using 'delete'.

Array lists can't be allocated on the stack currently.")

(bind-func ArrayL:[ArrayL{!a}*]*
  "
Create an ArrayList.
@param initial capacity for the ArrayList.
"
  (lambda (cap)
    (let ((data:!a (halloc cap))
          (zone (peek_zone))
          (arr (ArrayL_z data 0 cap )))
      (zone_cleanup (ArrayL_zhook arr))
      arr)))

(bind-func ArrayL:[ArrayL{!a}*]*
  "Creates an ArrayList with default capacity of 0"
  (lambda () (ArrayL 10)))

;; This is attached to the zone that this is created in and allows us
;; to cleanup the buffer used for Array storage.
(bind-func ArrayL_zhook:[void,ArrayL{!a}*]*
  (lambda (arr)
    (if (eq (tref arr 3) peek_zone)
        (free (tref arr 0)) void)))

(bind-func test
  (lambda () (println (let ((x:i8* (halloc 4))
                            (y:i64 (convert (pref-ptr x 0)))
                            (z:i64 (convert (pref-ptr x 1))))
                        (- z y)))))

($ (test))

(bind-func ArrayL_resize:[void,ArrayL{!a}*,i64]*
  (lambda (arr ncap)
    (let ((nloc (halloc ncap)))
      (memcpy (cast nloc i8*) (cast (tref arr 0) i8*) 

;; Operations should be:
;; add append insert pop (last element) set/get remove copy deep_copy
;; reverse sort
;; fill should also be supported.
;; NOTE: Sort should Timsort algorithm

(bind-func get:[Option{!}*,ArrayL{!a}*,i64]*
  "
Safe get. If you give it an index outside the array it will return None.
@param the array
@param index into the array (first element is 0)
"
  (lambda (arr idx)
    (let ((len) (tref arr 1))
      (if ((and) (> idx 0) (< idx (tref arr 1)))
          (Some (unsafe-get arr idx))
          (None)))))

;; might do this as a macro for extra speed
(bind-func unsafe-get:[Option{!a}*,Array{!a}*,i64]*
  (lambda (arr idx)
    (pref (tref arr 0) idx)))

;; foreach should be supported.
;; also slices, which would probably be something a little bit more generic. A function that
;; sits over a non-specific data structure.
;;
;; Resize factor for the ArrayList is 1.5
; If the size falls below 30% of capacity also resize it.
;; reserve - make sure the capacity is at least x?
;;
;;Need a way to copy this from one zone to another

(bind-func length:[i64,ArrayList{!a}*]*
  (lambda (arr)
    (tref arr 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; List

(bind-data List{!a}
           (Nil)
           (Cons !a List{!a}*))

;; print & toString for lists
(bind-func toString_help:[String*,List{!a}*,String*]*
  (lambda (lst s)
    (Cons$ lst (x xs)
              (Nil$ xs ()
                       (toString_help xs (cat s (toString x)))
                       (toString_help xs (cat s (toString x) (Str ","))))
              (cat s (Str "]")))))

(bind-func print:[void,List{!a}*]*
  (lambda (lst)
    (printout (toString_help lst (Str "[")))
    void))

(bind-func toString:[String*,List{!a}*]*
  (lambda (lst)
    (toString_help lst (Str "["))))

;; Inefficient. Need a tail recursion assistant.
(bind-func append:[List{!a}*,List{!a}*,List{!a}*]*
  (lambda (as bs)
    (Cons$ as (x xs) (Cons x (append xs bs)) bs)))

;; also known as 'flatten'
(bind-func join:[List{!a}*,List{List{!a}*}*]*
  (lambda (M)
    (Cons$ M (xs xss) (append xs (join xss)) (Nil))))

(bind-func fmap:[List{!b}*,[!b,!a]*,List{!a}*]*
  (lambda (f F)
    (Cons$ F (x xs) (Cons (f x) (fmap f xs)) (Nil))))

;; also known as 'bind'
(bind-func flatmap:[List{!b}*,List{!a}*,[List{!b}*,!a]*]*
  (lambda (M f)
    ;; alternate implementation using join and fmap
    ;; (join (fmap f M))))
    (Cons$ M (x xs) (append (f x) (flatmap xs f)) (Nil))))

;; also known as 'pure' or 'return'
(bind-func unit:[List{!a}*,!a]*
  (lambda (x)
    (Cons x (Nil))))

;; also known as 'ap' or '<*>'
(bind-func apply:[List{!b}*,List{[!b,!a]*}*,List{!a}*]*
  (lambda (F1 F2)
    (Cons$ F1 (f fs)
              (Cons$ F2 (x xs)
                        (Cons (f x) (apply fs xs))
                        (Nil))
              (Nil))))

;; also known as 'accum' or 'reduce' 
(bind-func foldl:[!b,[!b,!b,!a]*,!b,List{!a}*]*
  (lambda (fn start lst)
    (Cons$ lst (x xs)
           (foldl fn (fn start x) xs)
           start)))

(bind-func foldr:[!b,[!b,!b,!a]*,!b,List{!a}*]*
  (lambda (fn start lst)
    (Cons$ lst (x xs)
           (fn x (foldr fn start xs))
           start)))

;; list range function (inclusive min & max)
;; (bind-func range:[List{!a}*,!a,!a]*
;;   (lambda (mn mx)
;;     (if (> mn mx)
;;         (Nil)
;;         (Cons mn (range (+ mn (convert 1)) mx)))))

;; tail recursive version of range
(bind-func range:[List{!a}*,!a,!a,!a]*
  (lambda (mn mx i)
    (let ((rng (lambda (m x lst)
                 (if (< x m)
                     lst
                     (rng m (- x i) (Cons x lst))))))
      (rng mn mx (Nil)))))

(bind-func range:[List{!a}*,!a,!a]*
  (lambda (mn mx)
    (range mn mx (convert 1))))

(bind-func range:[List{!a}*,!a]*
  (lambda (mx)
    (range (convert 0) mx (convert 1))))

;; (bind-func reverse:[List{!a}*,List{!a}*]*
;;   (lambda (lst)
;;     (Cons$ lst (x xs)
;;            (append (reverse xs) (unit x))
;;            (Nil))))

;; tail recursive reverse
(bind-func reverse:[List{!a}*,List{!a}*]*
  (lambda (lst)
    (let ((rev (lambda (old new)
                 (if (Nil$ lst () #t #f)
                     rlst
                     (rev (Cons$ old (x xs) xs (Nil))
                          (Cons$ old (x xs)
                                    (Cons x new)
                                    (Nil)))))))
      (rev lst (Nil)))))

;; support 'List' abstraction 
;; (List 1 2 3 4) etc.. 
(define (PreludeList . args)
  (if (null? args) 
      `(Nil)
      (list 'Cons
            (car args)
            (apply PreludeList (cdr args)))))

(bind-macro (List . args) (apply PreludeList args))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; maybe 
;;

(bind-data Option{!a}
           (Some !a)
           (None))

(bind-func toString:[String*,Option{!a}*]*
  (lambda (F)
    (Some$ F (x)
              (toString x)
              '_')))

(bind-func print:[void,Option*]*
  (lambda (F)
    (printout (toString F))))

;; also known as map, lift
(bind-func fmap:[Option{!b}*,[!b,!a]*,Option{!a}*]*
  (lambda (f F)
    (Some$ F (x) (Some (f x)) (None))))

(bind-func join:[Option{!a}*,Option{Option{!a}*}*]*
  (lambda (M)
    (Some$ M (x) x (None))))

;; it's more convenient to have the function in last arg position
(bind-func flatmap:[Option{!b}*,Option{!a}*,[Option{!b}*,!a]*]*
  (lambda (M f)
    ;; (join (fmap f M)))) ;; alternate using join & fmap
    (Some$ M (x) (f x) (None))))    

;; also known as return or pure
(bind-func unit:[Option{!a}*,!a]*
  (lambda (x)
    (Some x)))

;; also known as <*> or ap
(bind-func apply:[Option{!b}*,Option{[!b,!a]*}*,Option{!a}*]*
  (lambda (F1 F2)
    (Some$ F1 (f)
              (Some$ F2 (x)
                        (Some (f x))
                        (None))
              (None))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Delimited Continuations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-type Cont{!r,!a} <[!r,[!r,!a]*]*>)

(bind-func cont_fn:[[!r,[!r,!a]*]*,Cont{!r,!a}*]*
  (lambda (cont) (tref cont 0)))

(bind-func runCont:[!r,Cont{!r,!a}*,!a]*
  (lambda (cont x) ((contFn cont) x)))

;; pass value `x` through the continuation
;; (bind-func just:[!r,[!r,!a]*]*
(bind-func just:[Cont{!r,!a}*,!a]*
  (lambda (x)
    (Cont (lambda (k) (k x)))))

(bind-func bind:[Cont{!r,!b}*,Cont{!r,!a}*,[Cont{!r,!b}*,!a]*]*
  (lambda (c f)
    (let ((cf (cont_fn c)))
      (Cont
       (lambda (k)
         (runCont (f (cf k)) k))))))

(bind-func abrupt:[Cont{!r,!a}*,!a]*
  (lambda (x) (Cont (lambda (k) x))))

